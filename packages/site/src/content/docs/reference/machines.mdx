---
title: Machines
description: The lifecycle of state-machines
sidebar:
  order: 5
---

import { Aside, Code, Steps } from "@astrojs/starlight/components";

To build state-machines with **yay-machine**:

<Steps>

1. Define the behaviour of the machine at compile-time

2. Create instances and operate the machine(s) at run-time

</Steps>

## Define at compile-time

We describe a state-machine's behaviour - it's potential [state types](/reference/state/), [event types](/reference/events/), [transitions](/reference/transitions/) and [side-effects](/reference/side-effects/) - with `defineMachine<StateType, EventType>({ /* ... */ })`, like so

{<Aside type="tip">
View this and other example's <a href="https://github.com/maurice/yay-machine/blob/main/packages/example-machines/src/tapeMachine.ts" target="_blank">source</a> and <a href="https://github.com/maurice/yay-machine/blob/main/packages/example-machines/src/__tests__/tapeMachine.test.ts" target="_blank">test</a> on GitHub

</Aside>}

import heaterMachine from "@yay-machine/example-machines/src/heater/heaterMachine.ts?raw";
import heaterMachineUsage from "@yay-machine/example-machines/src/heater/heaterMachineUsage.ts?raw";

<Code code={heaterMachine} lang="typescript" title="heaterMachine.ts" />

This creates a "blueprint" for machine instances.

## Operate at run-time

Once we have a machine-definition, we can easily create any number of machine-instances, start them, subscribe to their state, send them events, and eventually stop them.

<Code code={heaterMachineUsage} lang="typescript" />
